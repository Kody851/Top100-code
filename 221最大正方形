一、
https://leetcode-cn.com/problems/maximal-square/
博客：https://blog.csdn.net/juzihongle1/article/details/76039800
在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。
示例:
输入: 
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0
输出: 4

class Solution {
public:
    int maximalSquare(vector<vector<char>>& matrix) {
        if(matrix.empty()) return 0;
        int m=matrix.size(),n=matrix[0].size();
        //dp[i][j]表示以matrixdp[i][j]为正方形右下角的最大正方形边长
        vector<vector<int>>dp(m,vector<int>(n,0));
        int max=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(matrix[i][j]=='1'){
                    if(i==0||j==0) dp[i][j]=1;//处于第0行或第0列的，边长只可能是1或0
                    else dp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;//与之相邻的坐标最小的那个，加1
                }
                else dp[i][j]=0;//该位置是‘0’，肯定边长是0
                if(dp[i][j]>max) max=dp[i][j];
            }
        }
        return max*max;
    }
};
二、
相关题目 LeetCode.463. 岛屿的周长 https://leetcode-cn.com/problems/island-perimeter/
博客：https://blog.csdn.net/liyuanyue2017/article/details/81262666
给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。
网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。
岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。
示例 :
输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]
输出: 16
解释: 它的周长是下面图片中的 16 个黄色的边：
class Solution {
public:
    int islandPerimeter(vector<vector<int>>& grid) {
        int islands = 0;
        int neighbours = 0;
        for (int i = 0; i < grid.size(); i++) {
            for (int j = 0; j < grid[i].size(); j++) {
                if (grid[i][j] == 1) {
                    islands++;
                    if (i - 1 >= 0 && grid[i - 1][j] == 1)
                        neighbours++;
                    if (j - 1 >= 0 && grid[i][j - 1] == 1)
                        neighbours++;
                }
            }
        }
        return islands * 4 - neighbours * 2;
    }
};
当每次遇到新”岛屿”时，周长 + 4，但是有和之前的岛屿重合的边，这样两个”岛屿”的这条边都”废了”，不算入周长，周长 - 2 
可以得出公式：周长 = 岛屿数 * 4 - 重合边数 * 2
三、
0 ，1矩阵中含有连续全1块的个数
博客：https://blog.csdn.net/qq_35203425/article/details/82118617
class Solution {
public:
    int NumOfBlock(vector<vector<int>>& rect) {
        int count = 0;
        // 遍历矩阵找1,块的定位
        for (int i = 0; i < rect.size(); i++) {
            for (int j = 0; j < rect[i].size(); j++) {
                // 当找到1时,开始处理其所在的块
                if (rect[i][j] == 1) {
                    block(i, j);
                    count++;
                }
            }
        }
        return count;// 输出块数
    }

    // 判断连续块,递归
    private static void block(int i, int j) {
        // 修改(i,j)坐标对应的数组元素的值(避免递归时反复判断相邻元素)
        rect[i][j] = 4;
        // 分别判断上下左右
        if (i < rect.size() - 1 && rect[i + 1][j] == 1) {
            block(i + 1, j);
        }
        if (i > 0 && rect[i - 1][j] == 1) {
            block(i - 1, j);
        }
        if (j < rect[i].size() - 1 && rect[i][j + 1] == 1) {
            block(i, j + 1);
        }
        if (j > 0 && rect[i][j - 1] == 1) {
            block(i, j - 1);
        }
    }
};
